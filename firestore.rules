/**
 * This ruleset enforces a strict user-ownership model for the PoultrySense AI application.
 * It is designed for rapid prototyping, focusing on strong authorization while maintaining
 * flexibility in data schemas.
 *
 * Core Philosophy:
 * All user data is private and segregated. A user can only access data that exists
 * directly within their own data tree, identified by their unique user ID (UID). There is
 * no concept of public or shared data. This "data silo" approach ensures privacy and
 * simplifies security logic.
 *
 * Data Structure:
 * The data is organized hierarchically under a top-level `users` collection.
 * - /users/{userId}: Stores a user's public profile information.
 * - /users/{userId}/diagnoses/{diagnosisId}: A subcollection containing all diagnostic
 *   records created by that specific user.
 *
 * Key Security Decisions:
 * - Strict Ownership: All operations (read, write, delete) are restricted to the
 *   authenticated owner of the data.
 * - No User Listing: To protect user privacy, it is impossible to query or list all
 *   documents in the top-level `/users` collection.
 * - Path-Based Security: Authorization is primarily derived from the document's path,
 *   making rules fast and efficient. For example, access to any document under
 *   `/users/{userId}` requires the requester's UID to match the `{userId}` in the path.
 *
 * Denormalization for Authorization:
 * To create simple and performant rules, key authorization fields are denormalized:
 * - The `User` document at `/users/{userId}` contains an `id` field that must match the
 *   `userId` from the path.
 * - Each `Diagnosis` document under `/users/{userId}/diagnoses` contains a `userId` field
 *   that must also match the `userId` from the path.
 * This practice ensures data integrity and allows rules to validate ownership without
 * needing costly `get()` calls to parent documents.
 *
 * Structural Segregation:
 * All user-specific data (like diagnoses) is stored in a private subcollection under
 * the user's document. This is a secure and performant pattern that naturally prevents
 * data leakage between users and aligns perfectly with Firestore's query model.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for readable and reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user's UID matches the provided userId.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // For update/delete, ensures the document exists and the user is the owner.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own user profile document for the first time.
     * @deny (list) An attacker attempting to list all user profiles in the database.
     * @principle Restricts access to a user's own data tree and prevents enumeration of all users.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages individual diagnosis records for a specific user.
     * @path /users/{userId}/diagnoses/{diagnosisId}
     * @allow (create) An authenticated user creating a new diagnosis record for themselves.
     * @deny (get) A user trying to read another user's diagnosis record by guessing its ID.
     * @principle Enforces document ownership for all operations within a user's private subcollection.
     */
    match /users/{userId}/diagnoses/{diagnosisId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }
  }
}